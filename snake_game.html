<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <meta name="description" content="Jeu Snake classique avec contr√¥les tactiles et personnalisation">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Snake">
    <link rel="manifest" href="manifest.json">
    <title>üêç Jeu Snake Pro</title>
    <style>
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            color: white;
            overflow-x: hidden;
        }
        
        #header {
            width: 100%;
            max-width: 800px;
            padding: 15px;
            text-align: center;
        }
        
        h1 {
            margin: 0;
            font-size: clamp(20px, 5vw, 32px);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        #gameContainer {
            width: 100%;
            max-width: 800px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        
        #scoreArea {
            width: 100%;
            display: flex;
            justify-content: space-around;
            background: rgba(255,255,255,0.15);
            padding: 12px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .score-item {
            text-align: center;
            flex: 1;
            min-width: 100px;
        }
        
        .score-label {
            font-size: 12px;
            opacity: 0.9;
            margin-bottom: 3px;
        }
        
        .score-value {
            font-size: 24px;
            font-weight: bold;
        }
        
        #gameArea {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }
        
        #canvasContainer {
            position: relative;
            margin: 10px 0;
        }
        
        #gameBoard {
            border: 4px solid white;
            background-color: #1a1a2e;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            display: block;
            border-radius: 8px;
        }
        
        #gameOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.85);
            border-radius: 8px;
            flex-direction: column;
            gap: 15px;
            padding: 20px;
        }
        
        #gameOverlay.active {
            display: flex;
        }
        
        #overlayText {
            font-size: 32px;
            font-weight: bold;
            text-align: center;
        }
        
        #overlaySubtext {
            font-size: 18px;
            text-align: center;
            opacity: 0.9;
        }
        
        /* Contr√¥les */
        #controlsArea {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        
        #touchControls {
            position: relative;
            width: 200px;
            height: 200px;
            margin: 10px auto;
        }
        
        .touch-button {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.25);
            border: 3px solid white;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            cursor: pointer;
            user-select: none;
            transition: all 0.1s;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .touch-button:active {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(0.92);
        }
        
        #btnUp { top: 0; left: 70px; }
        #btnDown { bottom: 0; left: 70px; }
        #btnLeft { top: 70px; left: 0; }
        #btnRight { top: 70px; right: 0; }
        
        #buttonArea {
            display: flex;
            gap: 10px;
            width: 100%;
            max-width: 400px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            padding: 14px 24px;
            font-size: 16px;
            background: rgba(76, 175, 80, 0.9);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            flex: 1;
            min-width: 120px;
        }
        
        button:hover {
            background: rgba(69, 160, 73, 1);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .danger-btn {
            background: rgba(244, 67, 54, 0.9) !important;
        }
        
        .danger-btn:hover {
            background: rgba(218, 25, 11, 1) !important;
        }
        
        .secondary-btn {
            background: rgba(255, 152, 0, 0.9) !important;
        }
        
        .secondary-btn:hover {
            background: rgba(245, 124, 0, 1) !important;
        }
        
        /* Panneau des param√®tres - Collapsible sur mobile */
        #settingsPanel {
            width: 100%;
            max-width: 400px;
            background: rgba(255,255,255,0.15);
            padding: 0;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            overflow: hidden;
        }
        
        #settingsHeader {
            padding: 15px 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            background: rgba(0,0,0,0.1);
        }
        
        #settingsHeader h2 {
            margin: 0;
            font-size: 18px;
        }
        
        #settingsToggle {
            font-size: 24px;
            transition: transform 0.3s;
        }
        
        #settingsToggle.open {
            transform: rotate(180deg);
        }
        
        #settingsContent {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            padding: 0 20px;
        }
        
        #settingsContent.open {
            max-height: 1000px;
            padding: 20px;
        }
        
        .setting-group {
            margin-bottom: 20px;
        }
        
        .setting-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            font-size: 14px;
        }
        
        .setting-group input[type="color"] {
            width: 100%;
            height: 45px;
            border: 2px solid white;
            border-radius: 8px;
            cursor: pointer;
        }
        
        .setting-group input[type="range"] {
            width: 100%;
            cursor: pointer;
            height: 6px;
        }
        
        .setting-group select {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: 2px solid white;
            background: rgba(255,255,255,0.2);
            color: white;
            font-size: 16px;
            cursor: pointer;
        }
        
        .setting-group select option {
            background: #667eea;
            color: white;
        }
        
        .value-display {
            text-align: center;
            margin-top: 5px;
            font-size: 15px;
            font-weight: bold;
        }
        
        .color-preview {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .color-box {
            flex: 1;
            height: 35px;
            border: 2px solid white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        #highScoresList {
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
        }
        
        .high-score-item {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
        }
        
        .medal {
            margin-right: 8px;
        }
        
        /* Responsive Mobile */
        @media (max-width: 768px) {
            body {
                padding: 0;
            }
            
            #header {
                padding: 10px;
            }
            
            h1 {
                font-size: 24px;
            }
            
            #gameContainer {
                padding: 5px;
            }
            
            #touchControls {
                display: block !important;
            }
            
            #settingsContent.open {
                max-height: 800px;
            }
            
            .score-value {
                font-size: 20px;
            }
        }
        
        @media (max-width: 400px) {
            .touch-button {
                width: 55px;
                height: 55px;
                font-size: 24px;
            }
            
            #btnUp, #btnDown { left: 62px; }
            #btnLeft, #btnRight { top: 62px; }
            
            #touchControls {
                width: 180px;
                height: 180px;
            }
        }
        
        /* Desktop */
        @media (min-width: 769px) {
            #touchControls {
                display: none;
            }
            
            #settingsContent {
                max-height: none;
                padding: 20px;
            }
            
            #settingsHeader {
                cursor: default;
            }
            
            #settingsToggle {
                display: none;
            }
        }
        
        /* Animations */
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .pulse {
            animation: pulse 0.5s ease-in-out;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }
        
        .shake {
            animation: shake 0.3s ease-in-out;
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>üêç Snake Game Pro</h1>
    </div>
    
    <div id="gameContainer">
        <div id="scoreArea">
            <div class="score-item">
                <div class="score-label">Score</div>
                <div class="score-value" id="currentScore">0</div>
            </div>
            <div class="score-item">
                <div class="score-label">Record</div>
                <div class="score-value" id="highScore">0</div>
            </div>
            <div class="score-item">
                <div class="score-label">Niveau</div>
                <div class="score-value" id="levelDisplay">1</div>
            </div>
        </div>
        
        <div id="gameArea">
            <div id="canvasContainer">
                <canvas id="gameBoard" width="400" height="400"></canvas>
                <div id="gameOverlay">
                    <div id="overlayText">Game Over!</div>
                    <div id="overlaySubtext">Score: <span id="finalScore">0</span></div>
                </div>
            </div>
        </div>
        
        <div id="controlsArea">
            <div id="touchControls">
                <div class="touch-button" id="btnUp">‚Üë</div>
                <div class="touch-button" id="btnLeft">‚Üê</div>
                <div class="touch-button" id="btnRight">‚Üí</div>
                <div class="touch-button" id="btnDown">‚Üì</div>
            </div>
            
            <div id="buttonArea">
                <button id="startButton" onclick="startGame()">üéÆ Jouer</button>
                <button id="pauseButton" onclick="togglePause()" disabled>‚è∏Ô∏è Pause</button>
                <button class="secondary-btn" onclick="toggleSound()">üîä Son: <span id="soundStatus">ON</span></button>
            </div>
        </div>
        
        <div id="settingsPanel">
            <div id="settingsHeader" onclick="toggleSettings()">
                <h2>‚öôÔ∏è Param√®tres & Records</h2>
                <span id="settingsToggle">‚ñº</span>
            </div>
            <div id="settingsContent">
                <div class="setting-group">
                    <label for="difficultySelect">Difficult√©:</label>
                    <select id="difficultySelect" onchange="updateDifficulty()">
                        <option value="easy">üê¢ Facile</option>
                        <option value="normal" selected>üêç Normal</option>
                        <option value="hard">üöÄ Difficile</option>
                        <option value="extreme">üíÄ Extr√™me</option>
                    </select>
                </div>
                
                <div class="setting-group">
                    <label for="snakeColor">Couleur du serpent:</label>
                    <input type="color" id="snakeColor" value="#4CAF50" onchange="updateColors()">
                </div>
                
                <div class="setting-group">
                    <label for="foodColor">Couleur de la nourriture:</label>
                    <input type="color" id="foodColor" value="#ff4444" onchange="updateColors()">
                </div>
                
                <div class="setting-group">
                    <label for="backgroundColor">Couleur du fond:</label>
                    <input type="color" id="backgroundColor" value="#1a1a2e" onchange="updateColors()">
                </div>
                
                <div class="color-preview">
                    <div class="color-box" id="previewSnake" style="background-color: #4CAF50;"></div>
                    <div class="color-box" id="previewFood" style="background-color: #ff4444;"></div>
                    <div class="color-box" id="previewBg" style="background-color: #1a1a2e;"></div>
                </div>
                
                <div class="setting-group" style="margin-top: 25px;">
                    <label>üçé Valeurs des Nourritures:</label>
                    <div id="foodInfo" style="background: rgba(0,0,0,0.2); padding: 12px; border-radius: 8px; font-size: 14px;">
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
                            <div>üçé Pomme: 10 pts</div>
                            <div>üçá Raisin: 12 pts</div>
                            <div>üçä Orange: 13 pts</div>
                            <div>üçå Banane: 15 pts</div>
                            <div>ü•ù Kiwi: 16 pts</div>
                            <div>üçí Cerise: 18 pts</div>
                            <div>üçì Fraise: 20 pts</div>
                            <div>üçâ Past√®que: 25 pts</div>
                        </div>
                        <div style="margin-top: 10px; font-size: 12px; opacity: 0.8; text-align: center;">
                            üí° Points √ó Niveau actuel
                        </div>
                    </div>
                </div>
                
                <div class="setting-group" style="margin-top: 25px;">
                    <label>üèÜ Meilleurs Scores:</label>
                    <div id="highScoresList"></div>
                </div>
                
                <button onclick="resetSettings()" style="margin-top: 15px;" class="secondary-btn">üîÑ R√©initialiser</button>
                <button onclick="clearHighScores()" style="margin-top: 10px;" class="danger-btn">üóëÔ∏è Effacer les scores</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameBoard');
        const ctx = canvas.getContext('2d');
        
        // Configuration responsive
        function updateCanvasSize() {
            const maxSize = Math.min(window.innerWidth - 20, 400);
            canvas.width = maxSize;
            canvas.height = maxSize;
            gridSize = Math.floor(maxSize / 20);
            tileCount = 20;
            if (gameRunning) {
                draw();
            }
        }
        
        let gridSize = 20;
        let tileCount = 20;
        
        // Variables de personnalisation
        let snakeColor = '#4CAF50';
        let foodColor = '#ff4444';
        let backgroundColor = '#1a1a2e';
        
        // Variables de difficult√©
        let difficulty = 'normal';
        let baseSpeed = 100;
        let currentSpeed = 100;
        
        // Variables du serpent
        let snake = [{x: 10, y: 10}];
        let dx = 0;
        let dy = 0;
        let nextDx = 0;
        let nextDy = 0;
        
        // Variables de la nourriture
        let foodX = 15;
        let foodY = 15;
        let currentFood = null;
        
        // Types de nourriture avec leurs ic√¥nes et points
        const foodTypes = [
            { emoji: 'üçé', points: 10, name: 'Pomme' },
            { emoji: 'üçå', points: 15, name: 'Banane' },
            { emoji: 'üçá', points: 12, name: 'Raisin' },
            { emoji: 'üçì', points: 20, name: 'Fraise' },
            { emoji: 'üçä', points: 13, name: 'Orange' },
            { emoji: 'üçâ', points: 25, name: 'Past√®que' },
            { emoji: 'üçí', points: 18, name: 'Cerise' },
            { emoji: 'ü•ù', points: 16, name: 'Kiwi' }
        ];
        
        // Variables du jeu
        let score = 0;
        let level = 1;
        let gameRunning = false;
        let gamePaused = false;
        let gameLoop = null;
        let gameLoopId = null; // Nouveau: pour tracker l'ID exact
        let soundEnabled = true;
        
        // High scores
        let highScores = JSON.parse(localStorage.getItem('snakeHighScores')) || [];
        
        // Sons - Syst√®me simplifi√©
        function playSound(type) {
            if (!soundEnabled) return;
            
            try {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                
                let duration = 0.1;
                
                switch(type) {
                    case 'eat':
                        oscillator.frequency.value = 400;
                        duration = 0.1;
                        break;
                    case 'gameOver':
                        oscillator.frequency.value = 200;
                        duration = 0.3;
                        break;
                    case 'levelUp':
                        oscillator.frequency.value = 600;
                        duration = 0.2;
                        break;
                }
                
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + duration);
                
                // Fermer le contexte apr√®s le son
                setTimeout(() => {
                    audioCtx.close();
                }, duration * 1000 + 100);
            } catch(e) {
                console.log('Erreur audio:', e);
            }
        }
        
        // Initialisation
        window.addEventListener('load', () => {
            updateCanvasSize();
            loadHighScore();
            displayHighScores();
            draw();
        });
        
        window.addEventListener('resize', updateCanvasSize);
        
        // Contr√¥les clavier
        document.addEventListener('keydown', changeDirection);
        
        function changeDirection(event) {
            const key = event.key;
            
            if (key === 'ArrowUp' && dy === 0) {
                nextDx = 0; nextDy = -1;
            } else if (key === 'ArrowDown' && dy === 0) {
                nextDx = 0; nextDy = 1;
            } else if (key === 'ArrowLeft' && dx === 0) {
                nextDx = -1; nextDy = 0;
            } else if (key === 'ArrowRight' && dx === 0) {
                nextDx = 1; nextDy = 0;
            } else if ((key === 'z' || key === 'Z') && dy === 0) {
                nextDx = 0; nextDy = -1;
            } else if ((key === 's' || key === 'S') && dy === 0) {
                nextDx = 0; nextDy = 1;
            } else if ((key === 'q' || key === 'Q') && dx === 0) {
                nextDx = -1; nextDy = 0;
            } else if ((key === 'd' || key === 'D') && dx === 0) {
                nextDx = 1; nextDy = 0;
            } else if (key === ' ' || key === 'p' || key === 'P') {
                togglePause();
            }
        }
        
        // Contr√¥les tactiles
        function setupTouchControl(buttonId, dx, dy) {
            const button = document.getElementById(buttonId);
            
            button.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if ((dx !== 0 && this.dx === 0) || (dy !== 0 && this.dy === 0)) {
                    nextDx = dx;
                    nextDy = dy;
                }
            });
            
            button.addEventListener('click', () => {
                if ((dx !== 0 && this.dx === 0) || (dy !== 0 && this.dy === 0)) {
                    nextDx = dx;
                    nextDy = dy;
                }
            });
        }
        
        setupTouchControl('btnUp', 0, -1);
        setupTouchControl('btnDown', 0, 1);
        setupTouchControl('btnLeft', -1, 0);
        setupTouchControl('btnRight', 1, 0);
        
        function startGame() {
            console.log('=== START GAME ===');
            console.log('gameRunning avant:', gameRunning);
            console.log('gameLoopId avant:', gameLoopId);
            
            if (gameRunning) {
                console.log('‚ö†Ô∏è Jeu d√©j√† en cours, on ignore');
                return;
            }
            
            // Arr√™ter absolument tout
            stopGame();
            
            // Attendre un peu que tout soit bien arr√™t√©
            setTimeout(() => {
                // R√©initialiser le jeu
                snake = [{x: 10, y: 10}];
                dx = 1;
                dy = 0;
                nextDx = 1;
                nextDy = 0;
                score = 0;
                level = 1;
                gamePaused = false;
                
                updateDifficulty();
                placeFood();
                updateScore();
                
                document.getElementById('startButton').textContent = 'üéÆ En cours...';
                document.getElementById('startButton').disabled = true;
                document.getElementById('pauseButton').textContent = '‚è∏Ô∏è Pause';
                document.getElementById('pauseButton').disabled = false;
                document.getElementById('gameOverlay').classList.remove('active');
                
                // Redessiner imm√©diatement
                draw();
                
                // MAINTENANT on active le jeu
                gameRunning = true;
                
                // D√©marrer la boucle de jeu
                gameLoopId = setInterval(update, currentSpeed);
                gameLoop = gameLoopId;
                
                console.log('‚úÖ Jeu d√©marr√©');
                console.log('gameRunning apr√®s:', gameRunning);
                console.log('gameLoopId apr√®s:', gameLoopId);
            }, 50);
        }
        
        function stopGame() {
            console.log('=== STOP GAME ===');
            console.log('Arr√™t de gameLoopId:', gameLoopId);
            
            gameRunning = false;
            gamePaused = false;
            
            if (gameLoopId !== null) {
                clearInterval(gameLoopId);
                console.log('‚úÖ clearInterval appel√© sur:', gameLoopId);
                gameLoopId = null;
            }
            
            if (gameLoop !== null) {
                clearInterval(gameLoop);
                gameLoop = null;
            }
            
            console.log('gameRunning apr√®s stop:', gameRunning);
        }
        
        function togglePause() {
            if (!gameRunning) return;
            
            gamePaused = !gamePaused;
            const pauseBtn = document.getElementById('pauseButton');
            
            if (gamePaused) {
                console.log('‚è∏Ô∏è PAUSE - arr√™t gameLoopId:', gameLoopId);
                if (gameLoopId !== null) {
                    clearInterval(gameLoopId);
                    // Ne pas mettre √† null, on en aura besoin pour reprendre
                }
                pauseBtn.textContent = '‚ñ∂Ô∏è Reprendre';
                document.getElementById('overlayText').textContent = 'Pause';
                document.getElementById('overlaySubtext').textContent = 'Appuyez sur Espace ou le bouton pour continuer';
                document.getElementById('gameOverlay').classList.add('active');
            } else {
                console.log('‚ñ∂Ô∏è REPRISE');
                gameLoopId = setInterval(update, currentSpeed);
                gameLoop = gameLoopId;
                console.log('Nouveau gameLoopId:', gameLoopId);
                pauseBtn.textContent = '‚è∏Ô∏è Pause';
                document.getElementById('gameOverlay').classList.remove('active');
            }
        }
        
        function update() {
            // V√âRIFICATION CRITIQUE : Ne rien faire si le jeu n'est pas en cours
            if (!gameRunning || gamePaused) {
                return;
            }
            
            dx = nextDx;
            dy = nextDy;
            
            const head = {x: snake[0].x + dx, y: snake[0].y + dy};
            
            // V√©rifier les collisions avec les murs
            if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                gameOver();
                return;
            }
            
            // V√©rifier les collisions avec le corps
            for (let segment of snake) {
                if (head.x === segment.x && head.y === segment.y) {
                    gameOver();
                    return;
                }
            }
            
            snake.unshift(head);
            
            // V√©rifier si le serpent mange la nourriture
            if (head.x === foodX && head.y === foodY) {
                const points = currentFood ? currentFood.points : 10;
                score += points * level;
                playSound('eat');
                updateScore();
                
                // Animation de points gagn√©s
                showPointsAnimation(foodX, foodY, points * level);
                
                placeFood();
                
                // Augmenter le niveau tous les 50 points
                const newLevel = Math.floor(score / 50) + 1;
                if (newLevel > level) {
                    level = newLevel;
                    playSound('levelUp');
                    document.getElementById('levelDisplay').classList.add('pulse');
                    setTimeout(() => {
                        document.getElementById('levelDisplay').classList.remove('pulse');
                    }, 500);
                    
                    // Acc√©l√©rer le jeu - Arr√™ter et red√©marrer proprement
                    if (level > 1 && gameRunning && !gamePaused) {
                        console.log('üìà Changement de niveau:', level);
                        console.log('Ancien gameLoopId:', gameLoopId);
                        
                        // Arr√™ter l'ancien interval
                        if (gameLoopId !== null) {
                            clearInterval(gameLoopId);
                        }
                        
                        // Calculer la nouvelle vitesse
                        currentSpeed = Math.max(50, baseSpeed - (level - 1) * 10);
                        
                        // Cr√©er un nouveau interval
                        gameLoopId = setInterval(update, currentSpeed);
                        gameLoop = gameLoopId;
                        
                        console.log('Nouveau gameLoopId:', gameLoopId);
                        console.log('Nouvelle vitesse:', currentSpeed);
                    }
                }
            } else {
                snake.pop();
            }
            
            draw();
        }
        
        function draw() {
            // Effacer le canvas
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dessiner la grille
            ctx.strokeStyle = adjustBrightness(backgroundColor, 20);
            ctx.lineWidth = 1;
            for (let i = 0; i <= tileCount; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, canvas.height);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, i * gridSize);
                ctx.lineTo(canvas.width, i * gridSize);
                ctx.stroke();
            }
            
            // Dessiner le serpent avec un style r√©aliste
            snake.forEach((segment, index) => {
                const x = segment.x * gridSize;
                const y = segment.y * gridSize;
                
                if (index === 0) {
                    // T√äTE DU SERPENT - Style d√©taill√©
                    ctx.save();
                    
                    // Rotation selon la direction
                    ctx.translate(x + gridSize / 2, y + gridSize / 2);
                    if (dx === 1) ctx.rotate(0);
                    else if (dx === -1) ctx.rotate(Math.PI);
                    else if (dy === 1) ctx.rotate(Math.PI / 2);
                    else if (dy === -1) ctx.rotate(-Math.PI / 2);
                    
                    // Corps de la t√™te (forme ovale)
                    ctx.fillStyle = snakeColor;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, gridSize / 2 - 1, gridSize / 2.5 - 1, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Contour de la t√™te
                    ctx.strokeStyle = adjustBrightness(snakeColor, -40);
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Yeux (plus r√©alistes)
                    const eyeOffset = gridSize / 6;
                    const eyeSize = gridSize / 5;
                    
                    // Oeil gauche
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(eyeOffset, -eyeOffset, eyeSize, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.strokeStyle = adjustBrightness(snakeColor, -60);
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // Pupille gauche
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(eyeOffset + 1, -eyeOffset, eyeSize / 2.5, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Oeil droit
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(eyeOffset, eyeOffset, eyeSize, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.strokeStyle = adjustBrightness(snakeColor, -60);
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // Pupille droite
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(eyeOffset + 1, eyeOffset, eyeSize / 2.5, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Reflets dans les yeux
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.beginPath();
                    ctx.arc(eyeOffset - 1, -eyeOffset - 1, eyeSize / 4, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(eyeOffset - 1, eyeOffset - 1, eyeSize / 4, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Langue (si le serpent bouge)
                    if (dx !== 0 || dy !== 0) {
                        ctx.strokeStyle = '#ff1744';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(gridSize / 3, 0);
                        ctx.lineTo(gridSize / 2.2 + Math.sin(Date.now() / 100) * 2, -2);
                        ctx.moveTo(gridSize / 3, 0);
                        ctx.lineTo(gridSize / 2.2 + Math.sin(Date.now() / 100) * 2, 2);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                    
                } else {
                    // CORPS DU SERPENT - Style √©cailles
                    const prevSegment = snake[index - 1];
                    const nextSegment = snake[index + 1];
                    
                    // Couleur d√©grad√©e selon la position
                    const brightness = -5 - (index * 2);
                    ctx.fillStyle = adjustBrightness(snakeColor, brightness);
                    
                    // Corps avec coins arrondis selon la direction
                    const radius = gridSize / 4;
                    ctx.beginPath();
                    ctx.roundRect(x + 1, y + 1, gridSize - 2, gridSize - 2, radius);
                    ctx.fill();
                    
                    // Contour
                    ctx.strokeStyle = adjustBrightness(snakeColor, brightness - 30);
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    
                    // Motif d'√©cailles
                    ctx.fillStyle = adjustBrightness(snakeColor, brightness + 10);
                    ctx.globalAlpha = 0.5;
                    
                    // Petites √©cailles
                    const scaleSize = gridSize / 6;
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            ctx.beginPath();
                            ctx.arc(
                                x + (gridSize / 4) + i * (gridSize / 4),
                                y + (gridSize / 4) + j * (gridSize / 4),
                                scaleSize / 2,
                                0,
                                Math.PI,
                                false
                            );
                            ctx.fill();
                        }
                    }
                    ctx.globalAlpha = 1.0;
                    
                    // Effet de brillance sur le dessus
                    const gradient = ctx.createLinearGradient(x, y, x, y + gridSize);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.15)');
                    gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(x + 1, y + 1, gridSize - 2, gridSize / 2);
                }
            });
            
            // Dessiner la nourriture avec emoji
            if (currentFood) {
                const foodCenterX = foodX * gridSize + gridSize / 2;
                const foodCenterY = foodY * gridSize + gridSize / 2;
                
                // Ombre sous la nourriture
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(foodCenterX, foodCenterY + gridSize / 3, gridSize / 3, gridSize / 6, 0, 0, 2 * Math.PI);
                ctx.fill();
                
                // Animation de rebond
                const bounce = Math.sin(Date.now() / 200) * 2;
                
                // Dessiner l'emoji
                ctx.font = `${gridSize * 0.8}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(currentFood.emoji, foodCenterX, foodCenterY + bounce);
                
                // Effet de brillance/√©toile autour de la nourriture
                const sparkle = Math.sin(Date.now() / 150) * 0.5 + 0.5;
                ctx.strokeStyle = `rgba(255, 255, 100, ${sparkle})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                const starPoints = 8;
                for (let i = 0; i < starPoints * 2; i++) {
                    const radius = i % 2 === 0 ? gridSize / 2 + 5 : gridSize / 3;
                    const angle = (Math.PI * i) / starPoints;
                    const px = foodCenterX + Math.cos(angle) * radius;
                    const py = foodCenterY + Math.sin(angle) * radius + bounce;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.stroke();
            }
        }
        
        // Fonction helper pour roundRect (compatibilit√©)
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
                if (w < 2 * r) r = w / 2;
                if (h < 2 * r) r = h / 2;
                this.beginPath();
                this.moveTo(x + r, y);
                this.arcTo(x + w, y, x + w, y + h, r);
                this.arcTo(x + w, y + h, x, y + h, r);
                this.arcTo(x, y + h, x, y, r);
                this.arcTo(x, y, x + w, y, r);
                this.closePath();
                return this;
            };
        }
        
        // Animation de points flottants
        function showPointsAnimation(x, y, points) {
            const pointsDiv = document.createElement('div');
            pointsDiv.textContent = `+${points}`;
            pointsDiv.style.position = 'fixed';
            pointsDiv.style.color = '#FFD700';
            pointsDiv.style.fontWeight = 'bold';
            pointsDiv.style.fontSize = '24px';
            pointsDiv.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
            pointsDiv.style.pointerEvents = 'none';
            pointsDiv.style.zIndex = '1000';
            
            const canvasRect = canvas.getBoundingClientRect();
            const left = canvasRect.left + x * gridSize + gridSize / 2;
            const top = canvasRect.top + y * gridSize;
            
            pointsDiv.style.left = left + 'px';
            pointsDiv.style.top = top + 'px';
            pointsDiv.style.transform = 'translate(-50%, -50%)';
            
            document.body.appendChild(pointsDiv);
            
            // Animation
            let opacity = 1;
            let posY = 0;
            const animatePoints = setInterval(() => {
                opacity -= 0.05;
                posY -= 2;
                pointsDiv.style.opacity = opacity;
                pointsDiv.style.transform = `translate(-50%, calc(-50% + ${posY}px))`;
                
                if (opacity <= 0) {
                    clearInterval(animatePoints);
                    document.body.removeChild(pointsDiv);
                }
            }, 50);
        }
        
        function placeFood() {
            let validPosition = false;
            
            while (!validPosition) {
                foodX = Math.floor(Math.random() * tileCount);
                foodY = Math.floor(Math.random() * tileCount);
                
                validPosition = true;
                for (let segment of snake) {
                    if (segment.x === foodX && segment.y === foodY) {
                        validPosition = false;
                        break;
                    }
                }
            }
            
            // Choisir un type de nourriture al√©atoire
            currentFood = foodTypes[Math.floor(Math.random() * foodTypes.length)];
        }
        
        function updateScore() {
            document.getElementById('currentScore').textContent = score;
            document.getElementById('levelDisplay').textContent = level;
            
            const storedHighScore = parseInt(localStorage.getItem('snakeHighScore')) || 0;
            if (score > storedHighScore) {
                localStorage.setItem('snakeHighScore', score);
                document.getElementById('highScore').textContent = score;
                document.getElementById('highScore').classList.add('pulse');
                setTimeout(() => {
                    document.getElementById('highScore').classList.remove('pulse');
                }, 500);
            }
        }
        
        function loadHighScore() {
            const storedHighScore = parseInt(localStorage.getItem('snakeHighScore')) || 0;
            document.getElementById('highScore').textContent = storedHighScore;
        }
        
        function gameOver() {
            console.log('=== GAME OVER ===');
            console.log('gameRunning avant:', gameRunning);
            console.log('gameLoopId avant:', gameLoopId);
            
            // Arr√™ter le jeu imm√©diatement
            stopGame();
            
            // Attendre que tout soit bien arr√™t√©
            setTimeout(() => {
                // Jouer le son de game over
                playSound('gameOver');
                
                // Sauvegarder le score
                saveHighScore(score, difficulty);
                
                // Afficher le game over
                document.getElementById('finalScore').textContent = score;
                document.getElementById('overlayText').textContent = 'Game Over!';
                document.getElementById('overlaySubtext').innerHTML = `Score: ${score}<br>Niveau: ${level}`;
                document.getElementById('gameOverlay').classList.add('active');
                document.getElementById('canvasContainer').classList.add('shake');
                setTimeout(() => {
                    document.getElementById('canvasContainer').classList.remove('shake');
                }, 300);
                
                document.getElementById('startButton').textContent = 'üîÑ Rejouer';
                document.getElementById('startButton').disabled = false;
                document.getElementById('pauseButton').textContent = '‚è∏Ô∏è Pause';
                document.getElementById('pauseButton').disabled = true;
                
                displayHighScores();
                
                console.log('‚úÖ Game Over trait√©');
            }, 10);
        }
        
        function saveHighScore(score, difficulty) {
            if (score === 0) return;
            
            const newScore = {
                score: score,
                level: level,
                difficulty: difficulty,
                date: new Date().toLocaleDateString('fr-FR')
            };
            
            highScores.push(newScore);
            highScores.sort((a, b) => b.score - a.score);
            highScores = highScores.slice(0, 5); // Garder top 5
            
            localStorage.setItem('snakeHighScores', JSON.stringify(highScores));
        }
        
        function displayHighScores() {
            const list = document.getElementById('highScoresList');
            
            if (highScores.length === 0) {
                list.innerHTML = '<div style="text-align: center; opacity: 0.7;">Aucun score enregistr√©</div>';
                return;
            }
            
            const medals = ['ü•á', 'ü•à', 'ü•â', '4Ô∏è‚É£', '5Ô∏è‚É£'];
            const difficultyIcons = {
                'easy': 'üê¢',
                'normal': 'üêç',
                'hard': 'üöÄ',
                'extreme': 'üíÄ'
            };
            
            list.innerHTML = highScores.map((item, index) => `
                <div class="high-score-item">
                    <span><span class="medal">${medals[index]}</span>${item.score} pts</span>
                    <span>${difficultyIcons[item.difficulty]} Niv. ${item.level}</span>
                </div>
            `).join('');
        }
        
        function clearHighScores() {
            if (confirm('√ätes-vous s√ªr de vouloir effacer tous les scores ?')) {
                highScores = [];
                localStorage.removeItem('snakeHighScores');
                localStorage.removeItem('snakeHighScore');
                document.getElementById('highScore').textContent = '0';
                displayHighScores();
            }
        }
        
        function adjustBrightness(color, amount) {
            let usePound = false;
            if (color[0] === "#") {
                color = color.slice(1);
                usePound = true;
            }
            const num = parseInt(color, 16);
            let r = (num >> 16) + amount;
            let g = ((num >> 8) & 0x00FF) + amount;
            let b = (num & 0x0000FF) + amount;
            
            r = Math.max(Math.min(255, r), 0);
            g = Math.max(Math.min(255, g), 0);
            b = Math.max(Math.min(255, b), 0);
            
            return (usePound ? "#" : "") + (r << 16 | g << 8 | b).toString(16).padStart(6, '0');
        }
        
        function updateColors() {
            snakeColor = document.getElementById('snakeColor').value;
            foodColor = document.getElementById('foodColor').value;
            backgroundColor = document.getElementById('backgroundColor').value;
            
            document.getElementById('previewSnake').style.backgroundColor = snakeColor;
            document.getElementById('previewFood').style.backgroundColor = foodColor;
            document.getElementById('previewBg').style.backgroundColor = backgroundColor;
            
            draw();
        }
        
        function updateDifficulty() {
            difficulty = document.getElementById('difficultySelect').value;
            
            switch(difficulty) {
                case 'easy':
                    baseSpeed = 150;
                    break;
                case 'normal':
                    baseSpeed = 100;
                    break;
                case 'hard':
                    baseSpeed = 70;
                    break;
                case 'extreme':
                    baseSpeed = 50;
                    break;
            }
            
            currentSpeed = baseSpeed - (level - 1) * 10;
            
            if (gameRunning && !gamePaused) {
                clearInterval(gameLoop);
                gameLoop = setInterval(update, currentSpeed);
            }
        }
        
        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('soundStatus').textContent = soundEnabled ? 'ON' : 'OFF';
            document.querySelector('.secondary-btn').textContent = soundEnabled ? 'üîä Son: ON' : 'üîá Son: OFF';
        }
        
        function toggleSettings() {
            if (window.innerWidth > 768) return; // Seulement sur mobile
            
            const content = document.getElementById('settingsContent');
            const toggle = document.getElementById('settingsToggle');
            
            content.classList.toggle('open');
            toggle.classList.toggle('open');
        }
        
        function resetSettings() {
            document.getElementById('snakeColor').value = '#4CAF50';
            document.getElementById('foodColor').value = '#ff4444';
            document.getElementById('backgroundColor').value = '#1a1a2e';
            document.getElementById('difficultySelect').value = 'normal';
            
            updateColors();
            updateDifficulty();
        }
        
        // Enregistrer le Service Worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service-worker.js')
                    .then((registration) => {
                        console.log('Service Worker enregistr√©');
                    })
                    .catch((error) => {
                        console.log('Erreur Service Worker:', error);
                    });
            });
        }
    </script>
</body>
</html>
